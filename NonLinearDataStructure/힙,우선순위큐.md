## 힙(Heap)

- 완전 이진 트리 형태
    - 중복 값 허용
    - 반 정렬 상태
- 최소값 또는 최대값을 빠르게 찾아내는데 유용한 자료구조
    - 최소 힙, 최대 힙

### 최소 힙 (Min Heap)
- 부모 노드의 키가 자식 노드의 키보다 작거나 같은 형태

![](img/2022-04-29-18-26-35.png)

### 최소 힙 - 삽입
- 트리의 가장 끝 위치에 데이터 삽입
- 부모 노드와 키 비교한 후 작을 경우 부모 자리와 교체 (반복)

![](img/2022-04-29-18-28-46.png)

### 최소 힙 - 삭제

- 최상위 노드 반환 및 삭제
- 가장 마지막 위치의 노드를 최상위 노드로 위치 시킴
- 자식 노드 중 작은 값과 비교 후 부모 노드가 더 크면 자리 교체(반복)

![](img/2022-04-29-18-29-49.png)

## 우선순위 큐

### 우선순위 큐(Priority Queue)
- 우선순위가 높은 데이터가 먼저 나옴 (!= FIFO)
    - 모든 데이터에 우선순위가 있음
    - Dequeue 시, 우선순위가 높은 순으로 나감
    - 우선 순위가 같은 경우는 FIFO

### 우선순위 큐 - enqueue, dequeue
- 최소 힙 및 최대 힙의 삽입 삭제와 같음

![](img/2022-04-30-16-47-26.png)

### 우선순위 큐 - 구현
- 배열
- 연결 리스트
- 힙

![](img/2022-04-30-16-47-43.png)

### 우선순위큐 Java PriorityQueue 라이브러리
```java
/*
* PriorityQueue는 기본적으로 11길이의 length를 갖는다.
*/

// offer
/*
* modCount 
* transient modCount => 직렬화 과정에서 제외하고 초기값은 0이다. => modCount는 멀티쓰레드 동작으로 연산을 수행할시
*  => 해당 쓰레드의 변경여부를 파악해서 thread-safe를 구현할 수 있게하는 장치이다.
* siftUp(i,e) => i인덱스에 e 객체값을 넣는다.
*/
public boolean offer(E e) {
        if (e == null)
        // 객체 타입의 E의 e 객체가 비어있으면 NullException 발생
            throw new NullPointerException();
        // 
        modCount++;
        int i = size; // 큐 사이즈 받아오기
        if (i >= queue.length) 
            grow(i + 1); // 우선순위큐의 사이즈 증가
        siftUp(i, e); // siftup(값을 넣는 부분)
        size = i + 1;
        return true;
    }
/*
* k = size(우선순위 큐의 사이즈)
* comparator != null => 사용자 지정 Comparator가 있다면? siftUpUsingComparator 
* 없다면? => siftUpComarable
*/

private void siftUp(int k, E x) {
        if (comparator != null)
            siftUpUsingComparator(k, x, queue, comparator);
        else
            siftUpComparable(k, x, queue);
    }


/*
* 내부 용량을 증가시키는 메서드
* 외부에서 접근이 가능하면 안되므로 => private
*/
private void grow(int minCapacity) {
        int oldCapacity = queue.length;
        // Double size if small; else grow by 50%
        int newCapacity = ArraysSupport.newLength(oldCapacity,
                minCapacity - oldCapacity, /* minimum growth */
                oldCapacity < 64 ? oldCapacity + 2 : oldCapacity >> 1
                                           /* preferred growth */);
        queue = Arrays.copyOf(queue, newCapacity);
    }

/*
* e1 > e2 이면 1
* e1 < e2 이면 -1
* 동일하면 0
*/
public int compare(E e1, E e2){
  if(e1 > e2)
    return 1;
  else if e1 < e2
    return -1;
  else 
    return 0;
}
```

### siftUpUsingComparator / siftUpComparable
```java
// siftUpUsingComparator
private static <T> void siftUpUsingComparator(
        int k, T x, Object[] es, Comparator<? super T> cmp) {
        // 큐가 비어있지 않다면?
        while (k > 0) { 
            // parent => k -1 이후 오른쪽 시프트 연산자 이후 왼쪽을 모두 0으로 채운다.
            int parent = (k - 1) >>> 1;
            // parent 노드값을 가져온다.
            Object e = es[parent];
            // compare 를 실행한다 만약 0보다 크거나 같다면? => 현재 동작을 중지한다.
            if (cmp.compare(x, (T) e) >= 0)
                break;
            // es[k] = e => 노드가 새로 들어갈 자리에 부모 노드의 값을 넣는다.
            es[k] = e;
            // k = parent => es[k] = x 원래는 새로 들어온 값 이 들어갈 인덱스이나 여기서는 compare 결과가 0보다 작으므로 부모노드의 인덱스를 넣어준다.
            k = parent;
        }
        /*
        * 큐가 비어있다면 바로 값을 기입한다.
        * 큐가 비어있지 않다면? compare의 결과에 따라 다르다.
        * compare가 0보다 크거나 같다면? => 현재 들어온 값을 넣어야 되는 자리에 기입한다.
        * compare가 0보다 작다면? => 현재 들어온 값의 위치를 변경한다.
        */
        es[k] = x;
    }

// siftUpComparable
 private static <T> void siftUpComparable(int k, T x, Object[] es) {
        
        // Comparable의 key = 현재 들어온 객체 x 
        Comparable<? super T> key = (Comparable<? super T>) x;

        // k(size)가 0보다 크다면?
        while (k > 0) {
            // parent 노드 인덱스
            int parent = (k - 1) >>> 1;
            // parent 노드 value
            Object e = es[parent];
            // 현재들어온 객체 x의 compareTo(부모객체)가 0보다 크거나 같다면? => 기존의 값과 동일하다면
            if (key.compareTo((T) e) >= 0)
                break;
            // 지금 들어온 객체가 들어갈 인덱스에는 부모의 값이 들어가고
            es[k] = e;
            // 객체가 들어갈 인덱스에는 부모의 인덱스가 들어간다.
            k = parent;
        }
        /*
        k(size)가 0보다 작다면? => 현재들어온 객체값이 들어간다.
        k(size)가 0보다 크다면?
        1. 현재 들어온 객체와 부모객체의 compareTo함수의 결과값이 0보다 크다면? 
        => 앞으로 들어갈 인덱스에 현재 객체의 값이 들어간다.
        2. 현재 들어온 객체와 부모객체의 compareTo함수의 결과값이 0보다 작다면?
        => 앞으로 들어갈 인덱스에 부모 객체의 값이 들어가고
        => 현재 객체는 부모객체 인덱스에 값이 들어간다. (swap)
        */
        es[k] = key;
    }
```