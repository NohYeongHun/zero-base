## 에상 문제

## 2. 리눅스 환경에서 프로세스에 대한 설명
1. ps 명령어를 사용하면 실행중인 프로세스 정보를 확인할 수 있다.
2. 실행 중인 프로세스들은 고유한 프로세스 ID(PID)로 구분할 수 있다.
3. 실행 중인 임의의 프로세스에 대해, 해당 프로세스의 부모 프로세스 ID는 알 수 있다.(PPID)
4. Init 프로세스는 PID 1을 가지며 운영체제에서 생성된다.

## 3. C로 프로그램을 작성하는 중 현재 프로세스 ID(PID)를 얻고자 하는데 방법으로 옳은 것은?
- getpid() 함수를 사용한다.

## 4. 프로세스를 생성하기 위해서 준비해야 하는 공간(Segment)
1. STACK
2. HEAP
3. TEXT(CODE)
4. DATA


## 5. 프로세스 생성과 관련된 설명으로 옳은 것은?
- fork() 함수를 사용해 새로운 프로세스를 생성할 수 있으며 생성된 프로세스는 함수를 호출한 프로세스의 자식 프로세스가 된다.

- pid_t 자료형
    - 프로세스 ID를 저장하는 자료형

- fork()
> fork는 자식 프로세스를 만들기 위해서 사용되는 프로세스 생성기이다. fork에 의해 생성된 자식 프로세스는 자신만의 PID를 가지게 되며, PPID는 부모프로세스의 PID를 가지게 된다.
>
> 성공할 경우 자식 프로세스의 PID가 부모에게 리턴되며, 자식에게는 0이 리턴된다. 실패할 경우에는 -1이 리턴되고, 적절한 errno 값이 설정된다.

## 6. exec 계열 함수 (execl, execlp, ...)에 대한 설명
1. exec 함수는 현재 프로세스 이미지를 새로운 이미지로 교체한다.
2. execve() 함수를 사용하면 환경 변수(Environment variable)을 임의로 설정할 수 있다.
3. exec를 호출하는 코드에서 exec 뒤의 코드는 exec가 실패했을 때만 실행된다.
4. exec 계열 함수는 현재 프로세스 이미지를 별도 메모리 공간에 복사하지 않는다.

## 7. 프로세스 생성과 종료에 관하여 옳은 것
- wait 함수를 사용하면 자식 프로세스의 종료를 기다릴 수 있다.


## 8. 자식 프로세스 생성시 발생하는 메모리 복사 비용을 줄이기 위한 기법
- Copy-on-write

## 9. 리눅스 환경에서 부모 자식 관계의 두 프로세스가 있다. 각 프로세스의 메모리 공간에 대한 설명으로 옳은 것
- Copy-on-write 기법이 적용된 경우, 부모 프로세스와 자식 프로세스는 일부 메모리 공간을 공유할 수 있다.

## 10. 프로세스 종료에 관하여 옳은 것
1. exit() 함수를 사용하면 현재 프로세스를 즉시 종료할 수 있다.
2. 부모 프로세스는 자식 프로세스의 종료 상태 코드를 확인할 수 있다. wait() 이용
3. atexit() 함수를 사용하여 프로세스 종료시 실행할 함수를 등록할 수 있다.

## 11. 프로세스의 종료 상태 회수
- 부모 프로세스는 자식 프로세스의 종료 상태 코드를 WIFEXITED() 를 사용해 정상 종료인지 확인해 볼 수 있다.

## 12. 프로세스 스케쥴링과 관련한 설명
1. nice() 함수를 사용하여 프로세스의 우선 순위를 설정할 수 있다.
2. 프로세스에 설정된 우선 순위는 프로세스 스케쥴러에 따라 효과가 없을 수도 있다.
3. getpriority() 함수를 사용하면 프로세스, 프로세스 그룹, 유저에 따른 우선 순위를 읽어올 수 있다.
4. setpriority() 호출은 지정한 프로세스들 모두의 우선순위를 지정한 값으로 설정한다. 성공 시 0을 반환하고 실패 시 -1을 반환한다.

## 13. 프로세스간 커뮤니케이션(Inter-process Communication, IPC)에 관한 설명
1. 파이프(Pipe)는 단방향으로만 데이터 전송이 가능하다.
2. Pipe는 부모 프로세스에서 자식 프로세스로 데이터를 전송할 수 있다.
3. 메시지 큐(Message Queue)는 FIFO(First-in First-out) 방식으로 데이터 전송
4. Message Queue는 부모-자식 프로세스 뿐만 아니라 임의의 두 프로세스간 데이터 전송에 사용될 수 있다.

## 14. IPC 기법 중 공유 메모리와 관련된 함수
1. 공유 메모리 생성 
    -  int shmget(key_t key, size_t size, int shmflg);
2. 공유 메모리 연결
    - void *shmat(int shmid, const void *shmaddr, int shmflg);

3. 공유 메모리 해제
    - int shmdt(char *shmaddr);

4. 공유 메모리 제어
    - int shmctl(int shmid, int cmd, struct shmid_ds *buf);


## 15. 시그널에 관한 설명 
1. SIGKILL 시그널은 프로세스를 종료시키는 시그널이며 무시할 수 없다.
2. SIGTERM 시그널은 프로세스를 종료시키는 시그널이다.
3. 시그널의 종류와 번호는 kill -l 을 사용해 확인할 수 있다.

## 16. 쉘 스크립트에 대한 설명
1. 쉘 스크립트의 가장 첫줄 "#!/bin/bash"는 해당 스크립트가 bash 쉘을 통해 해석되야 함을 나타낸다.
2. echo를 사용하면 화면에 문자를 출력할 수 있다.
3. 실행하기 위해서는 실행 권한을 부여해야한다.



## 17. 쉘 스크립트 구문 중 옳은 문법
```c
name='Victor'
```

## 18. Pthread에 관한 설명
- POSIX Thread의 별칭이며 thread 생성 및 관리를 위한 핵심 라이브러리이다.
- Thread 동기화를 위한 API를 제공한다.
- pthread_mutex_lock, pthread_mutex_unlock 함수들을 사용해 Mutex를 사용할 수 있다.
- Pthread는 기본 라이브러리(glibc)에 포함되어 있지 않은 독립적인 라이브러리다. 그러므로 컴파일 과정에 있어서 다음과 같이 옵션을 붙여줘야 한다.
```
gcc -pthread test.c -o test
```

## 19. 다음 Pthread에 포함된 함수들에 대한 설명
- pthread_create(...) 함수는 thread를 생성하는 함수이며 thread가 실행할 함수를 지정해 줄 수 있다
- pthread_exit(...) 함수는 현재 실행중인 쓰레드를 종료시킨다.
- pthread_join(...) 함수는 스레드 종료를 대기하고 종료 상태를 회수한다.

## 20. 여러 쓰레드가 수행하고 있는 코드 중 일부이다. 다음 코드 라인 중 상호 배제가 보장되는 라인은?

```c
x = 0;
pthread_mutext_lock(&mut);
x = go_beyond(x); // 상호 배제 보장
pthread_mutex_unlock(&mut);
```

## 21. 다음은 pthread_create 함수의 인자들에 대한 설명

### pthread_create

- 스레드를 생성합니다. 함수 원형은 이렇습니다.

```c
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void*), void *arg)
```

- 이 함수는 현재 실행되고 있는 프로세스에서 새로운 스레드를 생성하는 함수입니다.

1. thread : 성공적으로 함수가 호출되면 이곳에 thread ID가 저장됩니다. 이 인자로 넘어온 값을 통해서 pthread_join과 같은 함수를 사용할 수 있습니다.

2. attr : 스레드의 특성을 정의합니다. 기본적으로 NULL을 지정합니다. 만약 스레드의 속성을 지정하려고 한다면 pthread_attr_init등의 함수로 초기화해야합니다.

3. start_routine : 어떤 로직을 할지 함수 포인터를 매개변수로 받습니다. 

4. arg : start_routine에 전달될 인자를 말합니다. start_routine에서 이 인자를 변환하여 사용합니다.

## 22. Pthread의 API 사용과 관련한 설명 
- Pthread API는 Semaphore를 포함하지 않는다.


## 23. Pthread 사용 중 Thread가 종료되었을 때 즉시 관련 리소스를 해제하도록 설정 하기 위해 사용할 수 있는 함수
- int pthread_detach(pthread_t thread);

## 24. 다음 메모리 맵핑 함수 mmap에 대한 설명
- mmap은 파일을 메모리 공간에 맵핑할 수 있다.
- mmap을 사용하기 위해서는 sys/mman.h 파일을 include 해야한다.
- 다른 프로세스와 공유할 수 있는 메모리 맵핑을 생성할 수 있다.

## 25. mmap 함수의 인자 중 prot은 맵핑하는 메모리 영역의 보호 모드를 설정
- prot : 보호 모드 설정, 권한 인자
- PROT_READ(읽기 가능) / PROT_WRITE(쓰기 가능) / PROT_EXEC(실행 가능) / PROT_NONE(접근 불가)

## 26. mmap을 이용한 파일 쓰기 단계
- mmap함수를 이용해 가상 메모리 주소에 파일을 맵핑함.
- 맵핑된 메모리 주소에 대해 데이터를 기록.
- 맵핑 해제와 파일 close.

## 27. mmap을 통해 맵핑한 메모리 공간을 해제하기 위한 함수
- munmap()

## 28. mmap을 사용해 맵핑한 메모리 주소 영역에 대해 동기화를 하기 위한 함수로 적절한 것은?
- msync()

## 29. 맵핑된 메모리 영역을 동기화 하는 방법 중 택할 수 있는 방식
- MS_ASYNC: 비동기 방식으로 결과에 관계 없이 프로그램 속행
- MS_SYNC: 동기 방식으로 결과를 확인 후 프로그램 속행
- MS_INVALIDATE: 현제 메모리 맵을 무효화함.

## 30. inode로 부터 얻을 수 있는 메타데이터와 관련 있는 것
- 파일의 소유자
- 파일의 크기
- 파일이 저장되어 있는 디렉토리의 이름

## 31. inode의 메타데이터를 얻기위한 함수
- stat, lstat, fstat 함수는 모두 stat함수처럼 파일의 정보를 stat구조체에 채우는 것으로 동일하지만,

- lstat함수는 stat와 다르게 한가지 경우를 제외한다.

- lstat함수는 path가 심볼릭 링크 파일 경우, 심볼릭 링크 파일에 대한 정보를 구조제체 채운다.
(stat함수는  원본의 정보를 채운다.)

- fstat함수는 stat, lstat와 첫 번째 인자가 다른데,

- fstat함수는 첫번째 인자로 파일 디스크립터 번호를 인자로 받고 stat와 동일한 기능을 수행한다.

- (여기서 파일 디스크립터 번호란, fileopen 등과 같이 open함수를 호출하면 생기는 번호이다.
