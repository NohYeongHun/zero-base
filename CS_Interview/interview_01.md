## 1. 세마포어(Semaphore)와 뮤텍스(Mutex)의 차이점에 대해 설명해주세요

- 뮤텍스는 오직 1개의 프로세스 혹은 스레드만이 공유 자원에 접근할 수 있고, 세마포어는 지정된 변수의 값만큼 접근할 수 있습니다. 
- 또한 세마포어는 운영체제 혹은 커널 단위에서 해당 리소스 변수가 관리되어 현재 공유 자원을 사용 중인 대상 뿐만아니라 다른 프로세스 및 스레드도 잠금 상태를 해제할 수 있지만 뮤텍스는 프로세스 단에서 관리되고 해당 변수(Lock)을 가지고 있기 때문에 Lock을 가지고 있는 변수만이 Unlock을 할 수 있습니다.

## 2. 데이터베이스의 트랜잭션에 대해서 설명해주세요
데이터베이스의 트랜잭션은 데이터베이스의 상태를 변화시키기 위해서 수행하는 작업의 단위이다.
트랜잭션은 주요한 4가지 성질을 가지고 있는데, 이는 원자성, 일관성, 독립성, 영속성이다.
1. 원자성
    - 트랜잭션의 연산이 데이터베이스에서 모두 반영되거나, 아예 반영이 안되어야 함.
    - 트랜잭션의 모든 명령은 완벽히 수행되어야 하며 수행이 되어지지 않을 시 트랜잭션 전부가 취소되어야 함.
2. 일관성
    - 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환
3. 독립성
    - 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우에는 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들면 안된다.
    - 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.
4. 영속성
    - 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

## 3. 로드 밸런싱과 로드밸런서에 대해 연관지어 설명해주세요.
- 네트워크 또는 서버에 가해지는 부하를 분산해주는 기술을 로드 밸런싱이라고 하는데 이를 수행하는 서비스 또는 장치를 로드밸런서 라고 정의한다.

- 로드밸런싱은 클라이언트가 웹 사이트를 방문하면 요청이 먼저 로드밸런서로 전송된 뒤에 클라이언트를 다른 서버로 안내함으로써 트래픽을 관리하는 방법론 이다.

- 이 때 하드웨어에서의 로드밸런서와 소프트웨어 로드 밸런서의 차이점이 있는데
하드웨어에서의 로드밸런서는 사용자 정의 구성으로 설정하기 때문에 확장성 측면에서 어려움이 있고 수요에 맞게 탄력적으로 확장, 축소를 할 수 없다.

- 소프트웨어 정의원칙에 따라 설계되어 있는
로드 밸런서의 경우에는 수요에 맞게 탄력적으로 확장, 축소가 가능하며, 가상, 컨테이너 및 클라우드와 호환된다.

1. 로드밸런싱과 로드밸런서
    - 로드밸런싱은 트래픽을 분산시켜 한 서버에 부담이 과중되도록 하지 않게 하는 기법이며, 이를 수행하는 장치를 로드밸런서라고 한다.

2. 로드밸런서의 기능
    1) Health-Check
서버에 장애가 있는지 주기적으로 체크한다. 일반적으로 서버의 포트가 있는지의 여부를 기준으로 Health-Check를 수행한다. 이때 한 서버에 이상이 생긴 것을 알게 된다면 다른 서버로 트래픽을 보낸다.
    2) NAT(Network Address Translation)
내부 네트워크에서 사용하는 사설 IP주소와 외부의 공인IP 주소를 변환하는 기능을 한다. 즉 여러 개의 호스트가 하나의 공인IP주소로 통신에 접속하는 것처럼 된다.
    3) DSR(Direct Server Return)
서버에서 클라이언트로 트래픽이 되돌아가는 경우 로드밸런서를 거치지 않고 바로 돌아갈 수 있도록 경로를 설정한다.

3. 로드밸런싱의 알고리즘
    1) 최소 분산 방식
현재 매핑되어있는 세션이 가장 적은 서버에 우선적으로 세션을 연결해주는 방식이다. 각 서버에 대한 연결 수를 동적으로 카운트할 수 있다.

    2) 라운드 로빈 방식
들어오는 트래픽을 서버 순서대로 배치한다. 세션의 처리 시간이 비슷하고 오래 사용되지 않을 경우에 사용하는 것이 좋다.

    3) 해쉬 방식
특정 기준을 잡아 특정 서버에 고정적으로 매핑해주는 방식이다. 이때 기준은 주로 IP가 된다.

## 4. 데이터베이스에서 이상현상의 종류와 각각의 정의
- 데이터베이스에서 정규화를 수행하지 않았을 때 데이터의 중복이 발생하고 전체적인 무결성이 저하되는데 이를 이상현상이라고 정의한다. 테이블 설계시 잘못 설계하여 생기는 논리적인 오류 라고 볼 수 있다.

이상현상의 종류
- 삽입 이상 :
다른 속성 없이 데이터베이스에 특정 속성을 삽입할 수 없을 때 발생한다.
자료 삽입 시 의도하지 않는 자료까지 삽입하여야 테이블에 데이터를 삽입이 가능한 경우이다.

- 삭제 이상 :
특정 정보를 삭제하면 유용한 다른 정보(원치 않는 정보)가 삭제되는 경우이다.


- 업데이트 이상 : 
데이터 중복 및 부분 업데이트의 경우에 발생하며 중복된 데이터중 일부만 수정되어 데이터 모순이 일어나는 경우이다.
예시로 부서를 따로 테이블로 관리하지 않는 경우 회사에서 동일한 사람 정보를 가지고 있는 두개의 데이터 행이 존재할 때 한쪽 행의 부서 정보를 변경하면 다른 한 행과 바꾼 행의 부서 정보는 서로 다른 상태가 된다.
(같은 회사이고 같은 사람인데 부서만 다른 상태)

## 5. Code, Data, Stack, Heap에 대해 설명해주세요.
- Code, Data, Stack, Heap은 일반적으로  메모리 표현에 대한 구역을 정의할 때 사용한다.

- Code<br>
    코드 영역 또는 Text 영역이라고 불리는데 실행 가능한 명령을 포함하는 파일 또는 메모리의 프로그램 구역중 하나이다.
    일반적으로  해당 영역은 공유가 가능하므로 단일 복사본만 존재하면 되고, 프로그램이 실수로 명령을 수정하는 것을 방지하기 위해 읽기전용으로 설정되어진다.

- Data는 초기화된 데이터 구역과 초기화 되지 않은 데이터 구역으로 나뉘는데
    - 초기화된 데이터 구역(data)
    프로그래머가 초기화하는 전역 변수와 정적 변수를 포함하는 프로그램 가상 주소 공간의 일부이다.
    이 구역에서 변수값들은 프로그램 실행 시 변경될 수 있으므로 해당 구역은 읽기전용이 아니다.

    - 초기화 되지 않은 데이터 구역(bss)은
    소스코드에서 명시적으로 초기화되지 않은 모든 전역변수 및 정적 변수를 포함하고,
    이 때 타입별로 기본 초기화 값을 가지고 있는 타입들은 자동으로 초기화되기도 한다.
    ex) int i => int i = 0;

- Stack<br>
    스택 영역은 메모리의 상위 부분에 위치한 프로그램 스택인 LIFO 구조가 포함된다. 지역변수, 매개변수, 복귀 번지 등이 저장되어 있는 프로그램이 자동으로 사용하는 임시메모리이다.
    Stack영역이 커지면 Heap 영역을 침범하고, 그 역도 성립한다.
    heap overflow => heap이 stack 영역을 침범
    stack overflow => stack이 heap 영역을 침범

- Heap<br>
    힙 영역은 동적 메모리 할당이 발당하는 구역이다. BSS 구역의 끝에서 시작하여 주소 값이 커지는 방향으로 이동한다. 
    C의 경우에는 malloc, realloc 및 free을 통해 프로그래머가 직접적으로 관리할 수 있다.

## 6. TCP 연결 시에는 3 way handshake고 해제 시에는 4 way handshake인 이유를 설명해주세요.

### TCP 프로토콜에서 사용하는 사전 지식.

- Code Bits
    - URG : 긴급 데이터
    - ACK : Ack Number 용 데이터
    - PSH : 수신측 버퍼가 다 찰때까지 기다리지 않고, 바로 전달 요청
    - RST : 접속 리셋 요청시 사용
    - SYN : 연결 요청시 사용
    - FIN : 연결 종료시 사용
- Sequence Number : 송신된 데이터의 순서 번호
- Ack Number : 수신된 데이터 순서번호 + 1(그 다음 데이터를 보내달라는 의미)

### 3 way handshake ( TCP 연결 설정)
1. Seq Num = 0, SYN(1) ex) (60451(client) = 운영체제 빈 포트 할당 -> 9999(목적지 PORT - server)) 
    - 클라이언트에서 서버에 데이터를 전송가능한지 SYN Bit를 on 한 뒤 송신
2. Seq Num = 0, Ack Num = (SeqNum + 1) SYN(1), ACK(1) (Server -> Clielnt)
    - 서버가 클라이언트에서 수신 받은 뒤 데이터 전송 가능하면 ACK Bit와 SYN Bit를 on 해서 송신
3. Seq Num = 1, Ack Num = 1, ACK(1) (Client -> Server)
    - 가능하다는 사인을 클라이언트가 수신한 뒤 데이터 전송을 하겠다고 서버에 다시 송신

```
TCP 연결설정에서 3 way handshake는 클라이언트와 서버간에 
양쪽 모두 데이터 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달 실시 전에
양 쪽 모두 다른 쪽이 준비되었다는 것을 알 수 있도록 한다.
```

### 4 way handshake ( TCP 연결 해제)
1. (Client -> Server) FIN(1), ACK(1) ,Seq Num = n
  - 클라이언트가 서버에 데이터 전송을 종료해도 되는지 물어본다.
2. (Server -> Client), ACK(1), Seq Num = 1, Ack Num = n + 1
  - 서버는 클라이언트에게 수신 데이터 번호(다음 실행 번호)를 보낸다.
3. (Server -> Client), ACK(1), FIN(1), Seq Num = 1, Ack Num = n + 1
  - 서버는 클라이언트에게 데이터 수신을 종료해도 괜찮다는 확인을 보낸다.
4. (Client -> Server), ACK(1), Seq Num = n + 1
  - 클라이언트는 확인을 받고 서버에게 송신 데이터 번호를 보낸 뒤 종료한다.

```
TCP 연결설정에서 4 way handshake는 클라이언트와 서버간에 
데이터 송수신을 종료해도 되는지를 확인하고 이를 통해 종료 전에
양 쪽 모두 다른 쪽이 준비되었다는 것을 확인하고 이를 실시한다.
```

## 7. 트랜잭션에서의 데드락이란 무엇이고 그 해결 방법을 설명해주세요.


### 사전 지식 : Lock
- 데이터 베이스 애플리케이션은 많은 사용자가 동일한 데이터에 동시에 액세스 하는 동시성을 제어해야 한다.
- 그렇지 않으면 데이터가 부적절하게 업데이트되거나 변경될 수 있다. 
- 예를 하나 들어보자면 사용자 카드의 계좌를 데이터 베이스로 관리한다고 했을 때, 사용자의 계좌에 카드가 여러개 연결되어 있고, 동시에 해당 카드들을 사용한다고 했을 때, db에서 동시성을 제어하지 않으면 잔액보다 많은 금액이 결제될 수 도 있는 오류가 발생할 수 있다. 


### Lock 사용 예시
```
계좌 잔액 : 10000
동시 결제
철수가 카드로 7000원 결제 
진구가 카드로 5000원 결제
정상적인 결과
=> 10000 - 7000 = 3000원
=> 진구의 카드 결제는 잔액 부족으로 결제가 되면 안됨.

Lock이 없는경우 비정상적인 결과
=> 10000 - 7000
=> 10000 - 5000
둘다 결제가 되는 비정상적인 상황이 발생할 수 있다.

그래서 데이터베이스 애플리케이션에서는 Lock을 통해 트랜잭션의 영향을 받는 개체를 잠그는 역할을 한다.
개체가 잠겨있는 동안에는 다른 트랜잭션이 들어왔을 때 잠금의
영향을 받는 개체에 저장된 데이터는 변경하지 못하도록 한다.
```

### DeadLock : 트랜잭션의 교착 상태
- 트랜잭션 A와 트랜잭션 B가 존재한다고 가정하고
이 둘이 모두 테이블 자원 x행과 y행을 공통적으로 필요로 한다고 할 때 트랜잭션 A는 x행을 가지고 Lock이 걸려있는 상태이고 트랜잭션 B는 y행을 가지고 Lock이 걸려있으면 
둘 다 필요로 하는 y행과 x행을 획득하지 못하여 교착상태가 발생한다.

- 이때 해결방법으로는 크게 예방법, 회피법, 탐지 및 제거 법이있다.


### 예방법
- deadlock이 발생할 수 있는 트랜잭션을 허용하지 않는다.
규칙으로는 둘 이상의 트랜잭션이 동일한 데이터 항목 잠금을 요청할 때 그 중 하나만 잠금이 부여된다는 것이다.

- 모든 트랜잭션이 사전 정의된 순서로 리소스에 액세스하도록 정렬한다.

```
예시 : 트랜잭션 A와 트랜잭션 B는
테이블 자원 x행과 y행을 사용할 때
둘다 동일하게 x행 -> y행 순서로 처리하게 하면
데드락이 발생할 확률이 줄어든다. 
```

- 가장 널리 사용되는 방지 방법 중 하나는 모든 잠금을 미리 획득하고 전체 트랜잭션 기간 동안 Lock을 유지하고, 다른 트랜잭션이 이미 획득한 Lock을 필요로 하는 경우 필요한 모든 Lock을 사용할 수 있을 때까지 기다려야 한다. 이렇게하면 대기 중인 트랜잭션이 Lock을 보유하고 있지 않기 때문에 DeadLock이 발생할 가능성을 없앤다.

### 회피법
- DeadLock이 발생하기 전에 처리하는 방법으로 트랜잭션과 Lock을 분석하여 대기상태가 DeadLock 상태로 이어지는 지여부를 결정한다.
- Lock 관리자가 Lock을 사용할 수 있는지 확인하고 사용 가능한 경우 데이터 행을 할당하고 트랜잭션이 Lock을 획득한다. 그러나 다른 트랜잭션에 의해 Lock이 잠긴 경우 트랜잭션을 대기 상태로 유지하면 DeadLock이 발생하는지 여부를 테스트하는 알고리즘을 실행한다.

- 이를 위한 두 가지 알고리즘이 있는데, wait-die 및 wound-wait가 있다.

- Wait-Die<br>
    오래된 트랜잭션을 T1, 새로운 트랜잭션을 T2라고 할 때 T2가 점유중인 자원이 있다면, T1은 대기하고 반대로 T1이 새로운 트랜잭션이라면 T1은 중단하고 나중에 시작한다.
- wound-wait<br>
    오래된 트랜잭션 T1이 점유중인 자원을 새로운 트랜잭션 T2가 요청하면 T2는 중단되고 나중에 시작된다. 반대의 상황이라면 T1은 대기한다.

### 탐지 및 제거법

- 교착 상태 감지 알고리즘을 주기적으로 실행하고 DeadLock 상태가 있는 경우 이를 제거한다. 예방 조치가 없기 때문에 일부 트랜잭션이 DeadLock에 빠질 수 있다.
- Lock 관리자는 교착 상태에 빠진 트랜잭션이 존재한다면 각 주기에서 트랜잭션을 선택하고 해당 트랜잭션은 중단되고 롤백한뒤 나중에 재시작한다.
- 트랜잭션을 선택하는 기준은 여러가지 있다.
    - 가장 최근 트랜잭션 선택.
    - 데이터 항목이 가장 적은 트랜잭션 선택
    - 업데이트를 가장 적게 수행한 트랜잭션 선택
    - 둘 이상의 주기에 공통되는 트랜잭션 선택


## 8. 페이지 교체 알고리즘에 대해 아는대로 설명.

### 페이징 시스템(paging system)
- 페이징(paging) 개념
    - 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
    - 하드웨어 지원이 필요
    - 예) Intel x86 시스템(32bit)에서는 4KB, 2MB, 1GB 지원
    리눅스에서는 4KB로 paging
    페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용

- 페이지 교체 알고리즘(FIFO)
    - 가장 먼저 들어온 페이지를 내리자

- 페이지 교체 알고리즘(OPT)
    - 최적 페이지 교체 알고리즘(OPTimal Replacement Algorithm)
    - 앞으로 가장 오랫동안 사용하지 않을 페이지를 내린다.

- 페이지 교체 알고리즘 (LRU)
    - LRU(Least Recently Used) Page Replacement Algorithm
    - 가장 오래 전에 사용된 페이지를 교체
    - OPT 교체 알고리즘이 구현이 불가하므로, 과거 기록을 기반으로 시도

- 페이지스왑알고리즘 (LFU)
    - LFU(LeastFrequentlyUsed) PageReplacementAlgorithm
    - 가장적게사용된페이지를내리자

- 페이지 스왑 알고리즘(NUR)
    - NUR(Not Used Recently) Page Replacement Algorithm
    - LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 교체하는 기법
    - 각페이지마다 참조 비트(R), 수정 비트(M)을 둠 (R,M)
    - (0, 0), (0, 1), (1, 0), (1, 1)순으로 페이지 교체