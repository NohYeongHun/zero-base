## 1. 세마포어(Semaphore)와 뮤텍스(Mutex)의 차이점에 대해 설명해주세요

- 뮤텍스는 오직 1개의 프로세스 혹은 스레드만이 공유 자원에 접근할 수 있고, 세마포어는 지정된 변수의 값만큼 접근할 수 있습니다. 
- 또한 세마포어는 운영체제 혹은 커널 단위에서 해당 리소스 변수가 관리되어 현재 공유 자원을 사용 중인 대상 뿐만아니라 다른 프로세스 및 스레드도 잠금 상태를 해제할 수 있지만 뮤텍스는 프로세스 단에서 관리되고 해당 변수(Lock)을 가지고 있기 때문에 Lock을 가지고 있는 변수만이 Unlock을 할 수 있습니다.

## 2. 데이터베이스의 트랜잭션에 대해서 설명해주세요
데이터베이스의 트랜잭션은 데이터베이스의 상태를 변화시키기 위해서 수행하는 작업의 단위이다.
트랜잭션은 주요한 4가지 성질을 가지고 있는데, 이는 원자성, 일관성, 독립성, 영속성이다.
1. 원자성
    - 트랜잭션의 연산이 데이터베이스에서 모두 반영되거나, 아예 반영이 안되어야 함.
    - 트랜잭션의 모든 명령은 완벽히 수행되어야 하며 수행이 되어지지 않을 시 트랜잭션 전부가 취소되어야 함.
2. 일관성
    - 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환
3. 독립성
    - 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우에는 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들면 안된다.
    - 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.
4. 영속성
    - 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

## 3. 로드 밸런싱과 로드밸런서에 대해 연관지어 설명해주세요.
- 네트워크 또는 서버에 가해지는 부하를 분산해주는 기술을 로드 밸런싱이라고 하는데 이를 수행하는 서비스 또는 장치를 로드밸런서 라고 정의한다.

- 로드밸런싱은 클라이언트가 웹 사이트를 방문하면 요청이 먼저 로드밸런서로 전송된 뒤에 클라이언트를 다른 서버로 안내함으로써 트래픽을 관리하는 방법론 이다.

- 이 때 하드웨어에서의 로드밸런서와 소프트웨어 로드 밸런서의 차이점이 있는데
하드웨어에서의 로드밸런서는 사용자 정의 구성으로 설정하기 때문에 확장성 측면에서 어려움이 있고 수요에 맞게 탄력적으로 확장, 축소를 할 수 없다.

- 소프트웨어 정의원칙에 따라 설계되어 있는
로드 밸런서의 경우에는 수요에 맞게 탄력적으로 확장, 축소가 가능하며, 가상, 컨테이너 및 클라우드와 호환된다.

1. 로드밸런싱과 로드밸런서
    - 로드밸런싱은 트래픽을 분산시켜 한 서버에 부담이 과중되도록 하지 않게 하는 기법이며, 이를 수행하는 장치를 로드밸런서라고 한다.

2. 로드밸런서의 기능
    1) Health-Check
서버에 장애가 있는지 주기적으로 체크한다. 일반적으로 서버의 포트가 있는지의 여부를 기준으로 Health-Check를 수행한다. 이때 한 서버에 이상이 생긴 것을 알게 된다면 다른 서버로 트래픽을 보낸다.
    2) NAT(Network Address Translation)
내부 네트워크에서 사용하는 사설 IP주소와 외부의 공인IP 주소를 변환하는 기능을 한다. 즉 여러 개의 호스트가 하나의 공인IP주소로 통신에 접속하는 것처럼 된다.
    3) DSR(Direct Server Return)
서버에서 클라이언트로 트래픽이 되돌아가는 경우 로드밸런서를 거치지 않고 바로 돌아갈 수 있도록 경로를 설정한다.

3. 로드밸런싱의 알고리즘
    1) 최소 분산 방식
현재 매핑되어있는 세션이 가장 적은 서버에 우선적으로 세션을 연결해주는 방식이다. 각 서버에 대한 연결 수를 동적으로 카운트할 수 있다.

    2) 라운드 로빈 방식
들어오는 트래픽을 서버 순서대로 배치한다. 세션의 처리 시간이 비슷하고 오래 사용되지 않을 경우에 사용하는 것이 좋다.

    3) 해쉬 방식
특정 기준을 잡아 특정 서버에 고정적으로 매핑해주는 방식이다. 이때 기준은 주로 IP가 된다.

## 4. 데이터베이스에서 이상현상의 종류와 각각의 정의
- 데이터베이스에서 정규화를 수행하지 않았을 때 데이터의 중복이 발생하고 전체적인 무결성이 저하되는데 이를 이상현상이라고 정의한다. 테이블 설계시 잘못 설계하여 생기는 논리적인 오류 라고 볼 수 있다.

이상현상의 종류
- 삽입 이상 :
다른 속성 없이 데이터베이스에 특정 속성을 삽입할 수 없을 때 발생한다.
자료 삽입 시 의도하지 않는 자료까지 삽입하여야 테이블에 데이터를 삽입이 가능한 경우이다.

- 삭제 이상 :
특정 정보를 삭제하면 유용한 다른 정보(원치 않는 정보)가 삭제되는 경우이다.


- 업데이트 이상 : 
데이터 중복 및 부분 업데이트의 경우에 발생하며 중복된 데이터중 일부만 수정되어 데이터 모순이 일어나는 경우이다.
예시로 부서를 따로 테이블로 관리하지 않는 경우 회사에서 동일한 사람 정보를 가지고 있는 두개의 데이터 행이 존재할 때 한쪽 행의 부서 정보를 변경하면 다른 한 행과 바꾼 행의 부서 정보는 서로 다른 상태가 된다.
(같은 회사이고 같은 사람인데 부서만 다른 상태)

## 5. Code, Data, Stack, Heap에 대해 설명해주세요.
- Code, Data, Stack, Heap은 일반적으로  메모리 표현에 대한 구역을 정의할 때 사용한다.

- Code<br>
    코드 영역 또는 Text 영역이라고 불리는데 실행 가능한 명령을 포함하는 파일 또는 메모리의 프로그램 구역중 하나이다.
    일반적으로  해당 영역은 공유가 가능하므로 단일 복사본만 존재하면 되고, 프로그램이 실수로 명령을 수정하는 것을 방지하기 위해 읽기전용으로 설정되어진다.

- Data는 초기화된 데이터 구역과 초기화 되지 않은 데이터 구역으로 나뉘는데
    - 초기화된 데이터 구역(data)
    프로그래머가 초기화하는 전역 변수와 정적 변수를 포함하는 프로그램 가상 주소 공간의 일부이다.
    이 구역에서 변수값들은 프로그램 실행 시 변경될 수 있으므로 해당 구역은 읽기전용이 아니다.

    - 초기화 되지 않은 데이터 구역(bss)은
    소스코드에서 명시적으로 초기화되지 않은 모든 전역변수 및 정적 변수를 포함하고,
    이 때 타입별로 기본 초기화 값을 가지고 있는 타입들은 자동으로 초기화되기도 한다.
    ex) int i => int i = 0;

- Stack<br>
    스택 영역은 메모리의 상위 부분에 위치한 프로그램 스택인 LIFO 구조가 포함된다. 지역변수, 매개변수, 복귀 번지 등이 저장되어 있는 프로그램이 자동으로 사용하는 임시메모리이다.
    Stack영역이 커지면 Heap 영역을 침범하고, 그 역도 성립한다.
    heap overflow => heap이 stack 영역을 침범
    stack overflow => stack이 heap 영역을 침범

- Heap<br>
    힙 영역은 동적 메모리 할당이 발당하는 구역이다. BSS 구역의 끝에서 시작하여 주소 값이 커지는 방향으로 이동한다. 
    C의 경우에는 malloc, realloc 및 free을 통해 프로그래머가 직접적으로 관리할 수 있다.

## 6. TCP 연결 시에는 3 way handshake고 해제 시에는 4 way handshake인 이유를 설명해주세요.

### TCP 프로토콜에서 사용하는 사전 지식.

- Code Bits
    - URG : 긴급 데이터
    - ACK : Ack Number 용 데이터
    - PSH : 수신측 버퍼가 다 찰때까지 기다리지 않고, 바로 전달 요청
    - RST : 접속 리셋 요청시 사용
    - SYN : 연결 요청시 사용
    - FIN : 연결 종료시 사용
- Sequence Number : 송신된 데이터의 순서 번호
- Ack Number : 수신된 데이터 순서번호 + 1(그 다음 데이터를 보내달라는 의미)

### 3 way handshake ( TCP 연결 설정)
1. Seq Num = 0, SYN(1) ex) (60451(client) = 운영체제 빈 포트 할당 -> 9999(목적지 PORT - server)) 
    - 클라이언트에서 서버에 데이터를 전송가능한지 SYN Bit를 on 한 뒤 송신
2. Seq Num = 0, Ack Num = (SeqNum + 1) SYN(1), ACK(1) (Server -> Clielnt)
    - 서버가 클라이언트에서 수신 받은 뒤 데이터 전송 가능하면 ACK Bit와 SYN Bit를 on 해서 송신
3. Seq Num = 1, Ack Num = 1, ACK(1) (Client -> Server)
    - 가능하다는 사인을 클라이언트가 수신한 뒤 데이터 전송을 하겠다고 서버에 다시 송신

```
TCP 연결설정에서 3 way handshake는 클라이언트와 서버간에 
양쪽 모두 데이터 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달 실시 전에
양 쪽 모두 다른 쪽이 준비되었다는 것을 알 수 있도록 한다.
```

### 4 way handshake ( TCP 연결 해제)
1. (Client -> Server) FIN(1), ACK(1) ,Seq Num = n
  - 클라이언트가 서버에 데이터 전송을 종료해도 되는지 물어본다.
2. (Server -> Client), ACK(1), Seq Num = 1, Ack Num = n + 1
  - 서버는 클라이언트에게 수신 데이터 번호(다음 실행 번호)를 보낸다.
3. (Server -> Client), ACK(1), FIN(1), Seq Num = 1, Ack Num = n + 1
  - 서버는 클라이언트에게 데이터 수신을 종료해도 괜찮다는 확인을 보낸다.
4. (Client -> Server), ACK(1), Seq Num = n + 1
  - 클라이언트는 확인을 받고 서버에게 송신 데이터 번호를 보낸 뒤 종료한다.

```
TCP 연결설정에서 4 way handshake는 클라이언트와 서버간에 
데이터 송수신을 종료해도 되는지를 확인하고 이를 통해 종료 전에
양 쪽 모두 다른 쪽이 준비되었다는 것을 확인하고 이를 실시한다.
```